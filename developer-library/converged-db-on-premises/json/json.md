# Oracle JSON

## Introduction

Steps 1-3
This lab walks you through the steps of setting up the environment for JSON lab . You can connect an Oracle Database instance using any client you wish. In this lab, you'll connect using Oracle SQLDeveloper.

Steps 4-6
This lab will show you how to create a simple external table that can read JSON documents from a dump file generated by a typical No-SQL style database. In this use case, the documents are contained in the file PurchaseOrders.dmp. The SQL directory object "ORDER_ENTRY" points to the folder containing the dump file and also points to the database’s trace folder. This trace folder also contains  ‘log’ or ‘bad’ files generated when the table is processed.  
**This is a Read-Only lab so the lab is already completed and json data was pre-loaded into the tables.**


Steps 7-9
This lab walks you through the steps of inserting and updating json data. We can use standard database APIs to insert or update JSON data. We can work directly with JSON data contained in file-system files by creating an external table that exposes it to the database.
In this lab we can add a row to our json table using insert query and  we can use Oracle SQL function json_mergepatch to update specific portions of a JSON document.

Steps 10-14
This lab walks you through modules where we will see improvements in the simplicity of querying JSON documents using SQL. We will also see materialized views query rewriting has been enhanced so that queries with JSON\_EXISTS, JSON\_VALUE and other functions can utilize a materialized view created over a query that contains a JSON\_TABLE function.

**Lab Prerequisites**

This lab assumes you have completed the following labs:
- Lab 1:  Login to Oracle Cloud
- Lab 2:  Generate SSH Key
- Lab 3:  Create Compute instance
- Lab 4:  Environment setup
- Note :  All scripts for this lab are stored in the /u01/workshop/json folder and are run as the oracle user.

**About Oracle JSON**

JSON (JavaScript Object Notation) is a syntax for storing and exchanging data. When exchanging data between a browser and a server, the data can only be text.

JSON is text, and we can convert any JavaScript object into JSON, and send JSON to the server. We can also convert any JSON received from the server into JavaScript objects.

This way we can work with the data as JavaScript objects, with no complicated parsing and translations.

**JSON with Oracle Database**

JSON data can be used in Oracle Databases in similar ways. Unlike relational data, it can be stored, indexed, and queried without any need for a schema that defines the data. Oracle Database supports JSON natively with relational database features, including transactions, indexing, declarative querying, and views.

It's likely we want to send and receive JSON documents to and from and our database, and store them in tables. Oracle Database has a huge amount of functionality that makes this easy.

Oracle database provides a comprehensive implemention of SQL, for both analytics and batch processing. JSON held in the Oracle Database can be directly accessed via SQL, without the need to convert it into an intermediary form. JSON collections can be joined to other JSON collections or to relational tables using standard SQL queries.

**Storing and Managing JSON Documents**

JSON documents can be stored usinga VARCHAR2, CLOB, or BLOB column. An IS JSON SQL constraint ensures that the column contains only valid JSON documents, allowing the database to understand that the column is being used as a container for JSON documents.

Oracle’s JSON capabilities are focused on providing full support for schemaless development and document-based storage. Developers are free to change the structure of their JSON documents as necessary. With the addition of JSON support, Oracle Database delivers the same degree of flexibility as a NoSQL JSON document store.

[](youtube:oiOCp23T1ZU)

The first thing to realize about JSON is that it remains a simple text format, which is relatively easy to read and inspect with the naked eye. At a syntax level, what starts to set JSON apart from other formats is the characters used to separate data, which are mainly constrained to apostrophes ', brackets ( ), [ ], { }, colons :, and commas ,. This listing illustrates what a JSON payload looks like:

![](./images/json_intro.png " ")


**Want to learn more**
- [JSON](https://docs.oracle.com/en/database/oracle/oracle-database/19/adjsn/index.html)

## Step 1: Connect to your Instance

**Oracle Cloud Shell**
1. Open Oracle Cloud Shell by clicking on the Cloud Shell icon in the top right corner.

    ![](./images/oracleshell.png " ")

2. Go to Compute -> Instance and select the instance you created (make sure you choose the correct compartment)

3. On the instance homepage, find the Public IP addresss for your instance.

4. Enter the command below to login to your instance.

    ````
    ssh -i ~/<sshkeylocation> opc@<Your Compute Instance Public IP address>
    ````

5. When prompted, answer yes to continue connecting.

**MAC or Windows CYGWIN Emulator**
1. Go to Compute -> Instance and select the instance you created (make sure you choose the correct compartment)

2. On the instance homepage, find the Public IP addresss for your instance.

3. Open up a terminal (MAC) or cygwin emulator as the opc user. Enter yes when prompted.

4. Enter the command below to login to your instance

    ````
    ssh -i ~/<sshkeylocation> opc@<Your Compute InstancePublic IP address>
    ````

**Windows using Putty**
1. Open up putty and connect to your instance.

    ````
    ssh -i ~/.ssh/optionskey opc@<Your Compute Instance Public IP Address>
    ````
    ![](./images/sshconnect.png " ")

2. Enter a name for the session and Click "Save".

    ![](./images/puttyconnect.png " ")

3. Click **Connection > Data** in the left navigation pane and set the Auto-login username to root.

4. Click **Connection > SSH > Auth** in the left navigation pane and configure the SSH private key to use by clicking Browse under Private key file for authentication.

5. Navigate to the location where you saved your SSH private key file, select the file, and click Open. NOTE: You may not be able to connect while on any corporate VPN or in the Oracle office on clear-corporate (choose clear-internet if you are in an Oracle office).

    ![](./images/puttyconfig.png " ")

6. The file path for the SSH private key file now displays in the Private key file for authentication field.

7. Click Session in the left navigation pane, then click Save in the Load, save or delete a stored session Step.

8. Click Open to begin your session with the instance.

## Step 2: Setup
**Setup your Oracle Environment**
1. Open the Oracle Cloud Shell by clicking on the icon next to the reigon name.

    ![](./images/oracleshell.png " ")


2. As oracle user navigate to the json workshop directory by entering the following commands.

    ````
    <copy>
    sudo su - oracle
    </copy>
    ````

    ````
    <copy>
    cd /u01/workshop/json
    </copy>
    ````
    ![](./images/json1.png " ")

2. Set your environment variables to the ConvergedCDB home.

    ````
    <copy>
    . oraenv
    </copy>
    ````

    ````
    <copy>
    ConvergedCDB
    </copy>
    ````
    ![](./images/json2.png " ")

    ````
    <copy>
    sqlplus appjson/Oracle_4U@JXLPDB
    </copy>
    ````
    ![](./images/json3.png " ")

**Connect to Sql Developer**

1. Download Sql Developer for your device.[https://www.oracle.com/tools/downloads/sqldev-downloads.html](https://www.oracle.com/tools/downloads/sqldev-downloads.html). You will also need JDK 11 which can be downloaded here [https://www.oracle.com/java/technologies/javase-jdk11-downloads.html](https://www.oracle.com/java/technologies/javase-jdk11-downloads.html)

2. Under connections right click on "Oracle Connections" and click "New Connection"

    ![](./images/json4.png " ")

3.  Provide the details as below and click on connect.

    ````
    Name: opc
    Username: appjson
    Password: Oracle_4U
    Hostname: Instance Public IP address
    Port: 1521
    Service name: JXLPDB
    ````

  ![](./images/env_json.png " ")

4. Click Connect

**Create a directory**

We will create a directory which will point to the location where json dump file is stored-

  ````

  create or replace directory ORDER_ENTRY
  as '/home/oracle/Spatial/script/db-sample-schemas-19.2/order_entry/';

  ````

**Create a simple table to store JSON documents**
In Oracle there is no dedicated JSON data type. JSON documents are stored in the database using standard Oracle data types such as VARCHAR2, CLOB and BLOB.

In order to ensure that the content of the column is valid JSON data, a new constraint **IS JSON**, is provided that can be applied to a column. This constraint returns TRUE if the content of the column is well-formed, valid JSON and FALSE otherwise.

This first statement in this module creates a table which will be used to contain JSON documents. These statements can be entered using SQLdeveloper or the connection to SQLdeveloper from your local terminal.

````
create table PURCHASE_ORDER (
  ID            RAW(16) NOT NULL,
  DATE_LOADED   TIMESTAMP(6) WITH TIME ZONE,
  PO_DOCUMENT CLOB CHECK (PO_DOCUMENT IS JSON)
  )
/
````

This statement creates a very simple table, PURCHASE\_ORDER. The table has a column PO\_DOCUMENT of type CLOB. The IS JSON constraint is applied to the column PO\_DOCUMENT, ensuring that the column can store only well formed JSON documents.

## Step 3: Loading JSON Documents into the database  

This statement creates a simple external table that can read JSON documents from a dump file generated by a typical No-SQL style database. In this case, the documents are contained in the file PurchaseOrders.dmp. The SQL directory object ORDER\_ENTRY points to the folder containing the dump file, and also points to the database’s trace folder which will contain any ‘log’ or ‘bad’ files generated when the table is processed.

````
CREATE TABLE PURCHASE_EXT(
      JSON_DOCUMENT CLOB
      )
      ORGANIZATION EXTERNAL(
      TYPE ORACLE_LOADER
      DEFAULT DIRECTORY ORDER_ENTRY
      ACCESS PARAMETERS (
      RECORDS DELIMITED BY 0x'0A'
      DISABLE_DIRECTORY_LINK_CHECK  
      BADFILE ORDER_ENTRY: 'PURCHASE_EXT.bad'
      LOGFILE ORDER_ENTRY: 'PURCHASE_EXT.log'
      FIELDS(
      JSON_DOCUMENT CHAR(5000)
      )
      )
      LOCATION (
       ORDER_ENTRY:'PurchaseOrders.dmp'
      )
      )
      PARALLEL
      REJECT LIMIT UNLIMITED
/
````

## Steps 4: Loading data from the external table into JSON table

The following statement copies the JSON documents from the dump file into the PURCHASE\_ORDER table.

````
insert into PURCHASE_ORDER
  select SYS_GUID(), SYSTIMESTAMP, JSON_DOCUMENT
  from PURCHASE_EXT
  where JSON_DOCUMENT IS JSON
/
commit
/
````

![](./images/purchase_order_count.png " ")
![](./images/insert_ot.png " ")

## Step 5: Insert a record.

1. **Take a count of the rows in the json table-**

````
<copy>
  select count(*) from purchase_order;
</copy>
````

![](./images/insert_json.png " ")  

2. Insert a record.

````
<copy>
  INSERT INTO purchase_order
  VALUES (
  SYS_GUID(),
  to_date('05-MAY-2020'),
      '{"PONumber"             : 10001,
        "Reference"            : "SBELL-20141017",
        "Requestor"            : "Sarah Bell",
        "User"                 : "SBELL",
        "CostCenter"           : "A50",
        "ShippingInstructions" : {"name"    : "Sarah Bell",
        "Address" : {"street"  : "200 Sporting Green",
        "city"    : "South San Francisco",
        "state"   : "CA",
        "zipCode" : 99236,
        "country" : "United States of America"},
        "Phone"   : "983-555-6509"},
        "Special Instructions" : "Courier",
        "LineItems"            : [{"ItemNumber" : 1,
        "Part"       : {"Description" : "Making the Grade",
        "UnitPrice"   : 20,
        "UPCCode"     : 27616867759},
        "Quantity"   : 8.0},
        {"ItemNumber" : 2,
        "Part"       : {"Description" : "Nixon",
                                    "UnitPrice"   : 19.95,
                                    "UPCCode"     : 717951002396},
                                     "Quantity"   : 5},
                                    {"ItemNumber" : 3,
              "Part"       : {"Description" : "Eric Clapton: Best Of 1981-1999",
                                   "UnitPrice"   : 19.95,
                                   "UPCCode"     : 75993851120},
                                     "Quantity"   : 5.0}
                                    ]}');


 </copy>
````

The above insert query is also available as a sql file in the directory “/u01/workshop/json”.
The script is called as insert.sql. You can run this connecting to the SQL prompt.

Set your oracle environment and connect to PDB as **oracle** user.
````
<copy>
      . oraenv
      </copy>
````
````
<copy>
      ConvergedCDB
<copy>
````
````
<copy>
      sqlplus appjson/Oracle_4U@JXLPDB
</copy>
````
````
<copy>
      @insert.sql
</copy>
````

3. **Verify the count after insert.**

````
<copy>
      Select * from purchase_order j where j.po_document.PONumber=10001;
</copy>
````

![](./images/json.png " ")

**Note:** Please copy the red highlighted id which we will use in our next section of update query.

## Step 6: Update a Table.
We can use Oracle SQL function json-mergepatch or PL/SQL object-type method json-mergepatch() to update specific portions of a JSON document. In both cases we provide a JSON Merge Patch document, which declaratively specifies the changes to make to a a specified JSON document. JSON Merge Patch is an IETF standard.    

**Note:** In the above update query replace the id which we copied in previous step.

````
<copy>
        update purchase_order
         set    PO_DOCUMENT = json_mergepatch (
             PO_DOCUMENT,
             '{
               "Requestor" : "MSDhoni"
             }'
           )
        where id ='ID_copied_from_previous_step';

</copy>
````

![](./images/json_lab7_6.png " ")

## Step 7: Example Queries
1. Customers who ordered products from specific Geo location   

````
<copy>
         select j.PO_DOCUMENT.Reference,
         j.PO_DOCUMENT.Requestor,
         j.PO_DOCUMENT.CostCenter,
         j.PO_DOCUMENT.ShippingInstructions.Address.city
         from PURCHASE_ORDER j
         where j.PO_DOCUMENT.ShippingInstructions.Address.city = 'South San Francisco'
         /
</copy>
````

![](./images/select_count.png " ")

**Note:** Oracle database allows a simple ‘dotted’ notation to be used to perform a limited set of operations on columns containing JSON. In order to use the dotted notation, a table alias must be assigned to the table in the FROM clause, and any reference to the JSON column must be prefixed with the assigned alias. All data is returned as VARCHAR2(4000).


2. Find all customers who purchased an items tagged with a specific UPC

````
<copy>
         SELECT po.po_document.PONumber,po.po_document.Requestor
         FROM purchase_order po
         WHERE json_exists(po.po_document,'$?(@.LineItems.Part.UPCCode == 85391628927)');
</copy>
````

![](./images/count_po_document.png " ")

**Note:** The JSON\_EXISTS operator is used in the WHERE clause of a SQL statement. It is used to test whether or not a JSON document contains content that matches the provided JSON path expression.

The JSON\_EXISTS operator takes two arguments, a JSON column and a JSON path expression. It returns TRUE if the document contains a key that matches the JSON path expression, FALSE otherwise. JSON\_EXISTS provides a set of modifiers that provide control over how to handle any errors encountered while evaluating the JSON path expression.

[UPC, short form for  Universal Product Code, is a type of code printed on retail product packaging to aid in identifying a particular item. It consists of two parts – the machine-readable barcode, which is a series of unique black bars, and the unique 12-digit number beneath it.]


3. Find the customers who all are purchased a specific products based on PONumber
````
<copy>
         select D.* from PURCHASE_ORDER p,
         JSON_TABLE(
         p.PO_DOCUMENT,
         '$'
         columns(
                PO_NUMBER            NUMBER(10)                  path  '$.PONumber',
                REFERENCE            VARCHAR2(30 CHAR)           path  '$.Reference',
                REQUESTOR            VARCHAR2(32 CHAR)           path  '$.Requestor',
                USERID               VARCHAR2(10 CHAR)           path  '$.User',
                COSTCENTER           VARCHAR2(16)                path  '$.CostCenter',
                NESTED PATH '$.LineItems[*]'
         columns(
                  ITEMNO         NUMBER(16)             path '$.ItemNumber',
                  DESCRIPTION    VARCHAR2(32 CHAR)      path '$.Part.Description',
                  UPCCODE        VARCHAR2(14 CHAR)      path '$.Part.UPCCode',
                  QUANTITY       NUMBER(5,4)            path '$.Quantity',
                  UNITPRICE      NUMBER(5,2)            path '$.Part.UnitPrice'
                )
              )
            ) D
         where PO_NUMBER = 1600  
         /

</copy>
````

        ![](./images/specific_product1.png " ")


4. Find the customers who all are purchased a specific products based on the description of the product

````
<copy>
         select D.* from PURCHASE_ORDER p,
         JSON_TABLE(
         p.PO_DOCUMENT,
         '$'
         columns(
                PO_NUMBER            NUMBER(10)                  path  '$.PONumber',
                REFERENCE            VARCHAR2(30 CHAR)           path  '$.Reference',
                REQUESTOR            VARCHAR2(32 CHAR)           path  '$.Requestor',
                USERID               VARCHAR2(10 CHAR)           path  '$.User',
                COSTCENTER           VARCHAR2(16)                path  '$.CostCenter',
                NESTED PATH '$.LineItems[*]'
         columns(
                  ITEMNO         NUMBER(16)             path '$.ItemNumber',
                  DESCRIPTION    VARCHAR2(32 CHAR)      path '$.Part.Description',
                  UPCCODE        VARCHAR2(14 CHAR)      path '$.Part.UPCCode',
                  QUANTITY       NUMBER(5,4)            path '$.Quantity',
                  UNITPRICE      NUMBER(5,2)            path '$.Part.UnitPrice'
                )
              )
            ) D
         where description='A Walk on the Moon'
         /
</copy>
````

![](./images/specific_product2.png " ")

**Notes:** The JSON\_TABLE operator uses a set of JSON path expressions to map content from a JSON document into columns in the view. Once the contents of the JSON document have been exposed as columns, all of the power of SQL can be brought to bear on the content of JSON document.

5. How Many orders were done by a customer with minimum 7 quantity and unit price minimum 25$ in each order

For this , we will create two views as below:

````
<copy>
         create or replace view PURCHASE_ORDER_MASTER_VIEW
         AS SELECT M.* FROM PURCHASE_ORDER p,
         JSON_TABLE(p.PO_DOCUMENT,
          '$'
         columns
         PO_NUMBER NUMBER(10) PATH '$.PONumber',
         REFERENCE VARCHAR2(30 CHAR) PATH '$.Reference',
         REQUESTOR VARCHAR(128) PATH '$.Requestor',
          USERID VARCHAR2(10 CHAR) PATH '$.User',
         COSTCENTER VARCHAR2(16) PATH '$.CostCenter',
         SHIP_TO_NAME VARCHAR2(20 CHAR) PATH '$.ShippingInstructions.name',
         SHIP_TO_STREET VARCHAR2(32 CHAR) PATH '$.ShippingInstructions.Address.street',
          SHIP_TO_CITY VARCHAR2(32 CHAR) PATH '$.ShippingInstructions.Address.city',
          SHIP_TO_COUNTY VARCHAR2(32 CHAR) PATH '$.ShippingInstructions.Address.county',
        SHIP_TO_POSTCODE VARCHAR2(32 CHAR) PATH '$.ShippingInstructions.Address.postcode',
         SHIP_TO_STATE VARCHAR2(2 CHAR) PATH '$.ShippingInstructions.Address.state',
          SHIP_TO_PROVINCE VARCHAR2(2 CHAR) PATH '$.ShippingInstructions.Address.province',
         SHIP_TO_ZIP VARCHAR2(8 CHAR) PATH '$.ShippingInstructions.Address.zipCode',
         SHIP_TO_COUNTRY VARCHAR2(32 CHAR) PATH '$.ShippingInstructions.Address.country',
         SHIP_TO_PHONE VARCHAR2(24 CHAR) PATH '$.ShippingInstructions.Phone[0].number',
         INSTRUCTIONS VARCHAR2(2048 CHAR) PATH '$.SpecialInstructions') m
         /
</copy>
````

````
<copy>
create or replace view PURCHASE_ORDER_DETAIL_VIEW
         AS
         SELECT D.* FROM PURCHASE_ORDER p,
        JSON_TABLE(
         p.PO_DOCUMENT,
        '$'
         columns (
         PO_NUMBER NUMBER(10) PATH '$.PONumber',
         REFERENCE VARCHAR2(30 CHAR) PATH '$.Reference',
         REQUESTOR VARCHAR(128) PATH '$.Requestor',
         USERID VARCHAR2(10 CHAR) PATH '$.User',
         COSTCENTER VARCHAR2(16) PATH '$.CostCenter',
         SHIP_TO_NAME VARCHAR2(20 CHAR) PATH '$.ShippingInstructions.name',
         SHIP_TO_STREET VARCHAR2(32 CHAR) PATH '$.ShippingInstructions.Address.street',
         SHIP_TO_CITY VARCHAR2(32 CHAR) PATH '$.ShippingInstructions.Address.city',
         SHIP_TO_COUNTY VARCHAR2(32 CHAR) PATH '$.ShippingInstructions.Address.county',
         SHIP_TO_POSTCODE VARCHAR2(32 CHAR) PATH '$.ShippingInstructions.Address.postcode',
         SHIP_TO_STATE VARCHAR2(2 CHAR) PATH '$.ShippingInstructions.Address.state',
         SHIP_TO_PROVINCE VARCHAR2(2 CHAR) PATH '$.ShippingInstructions.Address.province',
         SHIP_TO_ZIP VARCHAR2(8 CHAR) PATH '$.ShippingInstructions.Address.zipCode',
          SHIP_TO_COUNTRY VARCHAR2(32 CHAR) PATH '$.ShippingInstructions.Address.country',
         SHIP_TO_PHONE VARCHAR2(24 CHAR) PATH '$.ShippingInstructions.Phone[0].number',
         INSTRUCTIONS VARCHAR2(2048 CHAR) PATH '$.SpecialInstructions',
         NESTED PATH '$.LineItems[*]'
         columns (
           ITEMNO        NUMBER(38) PATH '$.ItemNumber',
          DESCRIPTION   VARCHAR2(256 CHAR) PATH '$.Part.Description',
         UPCCODE       VARCHAR2(14 CHAR) PATH '$.Part.UPCCode',
        QUANTITY      NUMBER(12,4) PATH '$.Quantity',
        UNITPRICE     NUMBER(14,2) PATH '$.Part.UnitPrice'
         )
         )
         ) d
          /

</copy>
````

````
<copy>
       select PO_NUMBER, REFERENCE, INSTRUCTIONS, ITEMNO, UPCCODE, DESCRIPTION, QUANTITY, UNITPRICE
         from PURCHASE_ORDER_DETAIL_VIEW d
        where REQUESTOR = 'Steven King'
        and QUANTITY  > 7
        and UNITPRICE > 25.00
         /

</copy>
````

![](./images/json_fun_view1.png " ")
![](./images/json_fun_view2.png " ")  
![](./images/lab5_snap3.png " ")    



**Notes** The above statements show how, once the relational views have been created, the full power of SQL can now be applied to JSON content, without requiring any knowledge of the structure of the JSON or how to manipulate JSON using SQL.

6. Customer Purchase History Details with PRETTY

````
<copy>
select JSON_QUERY(PO_DOCUMENT,'$.LineItems[0]' PRETTY) LINEITEMS
 from PURCHASE_ORDER p
 where JSON_VALUE (PO_DOCUMENT,'$.Requestor') = 'Alexis Bull'
/
</copy>
````

![](./images/json_fun_5a.png " ")  

7. Customer Purchase History Details without PRETTY**

````
<copy>
select JSON_QUERY(PO_DOCUMENT,'$.LineItems[0]') LINEITEMS
 from PURCHASE_ORDER p
 where JSON_VALUE(PO_DOCUMENT,'$.Requestor') = 'Alexis Bull'
/
</copy>
````

![](./images/json_fun_5b.png " ")  

**Notes:** JSON\_QUERY finds one or more specified JSON values in JSON data and returns the values in a character string. expr. Use this clause to specify the JSON data to be evaluated. For expr , specify an expression that evaluates to a text literal.

JSON\_VALUE selects a scalar value from JSON data and returns it as a SQL value. You can also use json\_value to create function-based B-tree indexes for use with JSON data — see Indexes for JSON Data. Function json\_value has two required arguments and accepts optional returning and error clauses.

## Acknowledgements

- **Authors** - Balasubramanian Ramamoorthy, Arvind Bhope
- **Contributors** - Laxmi Amarappanavar, Kanika Sharma, Venkata Bandaru, Ashish Kumar, Priya Dhuriya, Maniselvan K, Robert Ruppel.
- **Team** - North America Database Specialists.
- **Last Updated By** - Kay Malcolm, Director, Database Product Management, June 2020
- **Expiration Date** - June 2021   

**Issues-**
Please submit an issue on our [issues](https://github.com/oracle/learning-library/issues) page. We review it regularly.
